Synchronize锁升级 （不可逆的）


在了解Synchronize原理前，我们先了解一下在jvm中一个对象的构成是怎样的？
1、对象头
    || MarkWord
        (1) hashcode
        (2) 分代年龄
        (3) 锁标志位
    || 类型指针
        就指对象指向类元数据的指针，jvm就是根据这个判断一个对象它属于那个类的
2、实例数据
3、填充对齐数据


无锁 -----> 偏向锁 -----> 轻量级锁 -----> 重量级锁

1、无锁状态

2、偏向锁原理
    偏向锁的就是说偏向第一个获得锁的线程，在线程进来加锁时，将线程的id写入锁对象的MarkWord中，当下次线程再进来时
    先判断线程的id是否和锁对象对象头的id是否一致，如果一致则直接执行同步代码，若不一致，则采用cas来竞争锁，
    新的线程竞争成功获得锁，则将锁对象的MarkWord的线程id替换为当前线程id，当cas竞争失败时，则进一步升级为轻量级锁

3、轻量级锁原理
    当一个线程进来，首先先判断当前对象是否无锁状态，若是，则jvm在该线程虚拟栈中开辟个空间叫lockRecord(锁记录)，
    并将锁对象的markword拷贝到lockRecord中，并且通过cas将锁对象原本的markword更新为lockRecord的指针地址，
    锁标志位变为00，即代表轻量级锁加锁成功；
    若失败了则转换为自旋锁自旋进行加锁，若达到自旋的最大次数还是未获得锁，则直接升级为重量级锁

4、synchronized
    1、同步代码块实现原理
        在代码编译之后，会在同步块前后加上两个指令 monitorenter 和 monitorexit
        当一个线程进来时，对应的锁标志位是01，代表无锁的状态，此时该线程会尝试获取同步块的锁对象嘛，
        与此同时还要获取到关联的monitor监视器锁对象，然后会在monitor的一个锁计数器+1，将monitor的指针写入到
        对象头中，并且修改对应的锁标志位为10，就对应的是重量级锁，以此完成一个换锁的过程
        并且这个过程是可重入，然后同一个线程再次进来获得锁时，直接可在monitor的计数器进行+1 来代表加锁，
        对应的释放锁的过程则需将计数器数目进行-1 实现一次释放锁，加多少次就释放多少次，从而实现整个加锁放锁
        的全过程
    2、同步方法实现原理
        代码编译之后，会生成一个ACC_SYNCHRONIZED标志位，就相当于一个flag，jvm检测到这个标志位后，就自动去走这个
        同步方法调用的这个策略
